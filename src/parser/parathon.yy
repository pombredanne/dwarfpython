/* This file was autogenerated by ./autogen.py. Changes will be reverted on build. */
%{
#line 285 "ast/autogen.py"

#include <cctype>
#include <cstring>
#include <stdio.h>
#include <iostream>
#include "ast.h"
#include "parathon.h"

extern "C" int line_num;
void evaluate(SingleInput * si, ParathonContext* context );
void yyerror(ParathonContext* context, char const *s)
{
    std::cout << "Syntax error, line " << line_num << std::endl;
}

%}

%define api.pure
%define api.push_pull "push"
%parse-param { ParathonContext* context }

%token TOK_ERROR

%token TOK_NEWLINE TOK_INDENT TOK_OUTDENT 
%token TOK_INTEGER TOK_FLOAT 
%token TOK_OPEN_SQUARE TOK_CLOSE_SQUARE TOK_OPEN_CURLY TOK_CLOSE_CURLY TOK_OPEN_CURVED TOK_CLOSE_CURVED 
%token TOK_NAME TOK_STRING 
%left TOK_DOT TOK_COMMA TOK_SEMICOLON
%token TOK_ASSIGN TOK_COLON TOK_AT TOK_BACKTICK
%left TOK_EQ TOK_GT TOK_GTEQ TOK_LT TOK_LTEQ TOK_NOTEQ
%left TOK_PLUS TOK_MINUS TOK_MULTIPLY TOK_DIVIDE TOK_TRUNC_DIVIDE TOK_MODULUS
%right TOK_POWER
%left TOK_BAND TOK_BOR TOK_BNOT TOK_BXOR
%left TOK_LEFTSHIFT TOK_RIGHTSHIFT
%token TOK_NOT
%left TOK_AND TOK_OR TOK_IN TOK_IS
%token TOK_IF TOK_ELIF TOK_ELSE
%token TOK_PASS TOK_RETURN TOK_YIELD TOK_PRINT 
%token TOK_FOR TOK_WHILE TOK_BREAK TOK_CONTINUE 
%token TOK_TRY TOK_ASSERT TOK_RAISE TOK_EXCEPT TOK_FINALLY 
%token TOK_CLASS TOK_DEF TOK_LAMBDA 
%token TOK_FROM TOK_GLOBAL TOK_IMPORT TOK_AS 
%token TOK_WITH TOK_DEL TOK_EXEC 

%union {
    ArithOperator *arith_operator;
    ComparisonOperator *comparison_operator;
    DottedName *dotted_name;
    MultOperator *mult_operator;
    ParameterList *parameter_list;
    ParameterListArgs *parameter_list_args;
    ParameterPhrase *parameter_phrase;
    ShiftOperator *shift_operator;
    SingleInput *single_input;
    SliceList *slice_list;
    SlicePhrase *slice_phrase;
    SmallStatement *small_statement;
    TestPhraseOptional *test_phrase_optional;
    UnaryOperator *unary_operator;
    AssignStatement *assign_statement;
    BreakStatement *break_statement;
    CompEq *comp_eq;
    CompGt *comp_gt;
    CompGtEq *comp_gt_eq;
    CompIn *comp_in;
    CompIs *comp_is;
    CompLt *comp_lt;
    CompLtEq *comp_lt_eq;
    CompNotEq *comp_not_eq;
    CompNotIn *comp_not_in;
    CompNotIs *comp_not_is;
    ContinueStatement *continue_statement;
    DeleteStatement *delete_statement;
    FunctionDefinition *function_definition;
    GlobalStatement *global_statement;
    IfStatement *if_statement;
    ImportStatement *import_statement;
    OpBand *op_band;
    OpBnot *op_bnot;
    OpBor *op_bor;
    OpBxor *op_bxor;
    OpDivide *op_divide;
    OpLeftShift *op_left_shift;
    OpMinus *op_minus;
    OpMod *op_mod;
    OpMult *op_mult;
    OpNegative *op_negative;
    OpPlus *op_plus;
    OpPositive *op_positive;
    OpPower *op_power;
    OpRightShift *op_right_shift;
    OpTrunc *op_trunc;
    ParameterListKwargs *parameter_list_kwargs;
    ParameterListNonArgs *parameter_list_non_args;
    PassStatement *pass_statement;
    PrintStatement *print_statement;
    ReturnStatement *return_statement;
    Suite *suite;
    TestStatement *test_statement;
    WhileStatement *while_statement;
    DottedAsNames *dotted_as_names;
    ImportAsNames *import_as_names;
    SuiteBody *suite_body;
    TestList *test_list;
    TestPhrase *test_phrase;
    InlineIfPhrase *inline_if_phrase;
    OrPhrase *or_phrase;
    SimpleStatement *simple_statement;
    TestListNonEmpty *test_list_non_empty;
    AndPhrase *and_phrase;
    TestListNonTrailing *test_list_non_trailing;
    NotPhrase *not_phrase;
    ComparisonPhrase *comparison_phrase;
    ComparisonList *comparison_list;
    Expression *expression;
    XorExpression *xor_expression;
    AndExpression *and_expression;
    ShiftExpression *shift_expression;
    ArithExpression *arith_expression;
    MultExpression *mult_expression;
    FactExpression *fact_expression;
    UnaryPhrase *unary_phrase;
    BasePhrase *base_phrase;
    FunctionCall *function_call;
    GetAttr *get_attr;
    GetItem *get_item;
    ListMaker *list_maker;
    NamePhrase *name_phrase;
    ReprPhrase *repr_phrase;
    TestPhraseBracketed *test_phrase_bracketed;
    TupleMaker *tuple_maker;
    ValueFloat *value_float;
    ValueInt *value_int;
    ValueString *value_string;
    /* lexer */
    long long int_val;
    double float_val;
    char *string;
    char *name;
}

%type <arith_operator> arith_operator
%type <comparison_operator> comparison_operator
%type <dotted_name> dotted_name
%type <mult_operator> mult_operator
%type <parameter_list> parameter_list
%type <parameter_list_args> parameter_list_args
%type <parameter_phrase> parameter_phrase
%type <shift_operator> shift_operator
%type <single_input> single_input
%type <slice_list> slice_list
%type <slice_phrase> slice_phrase
%type <small_statement> small_statement
%type <test_phrase_optional> test_phrase_optional
%type <unary_operator> unary_operator
%type <assign_statement> assign_statement
%type <break_statement> break_statement
%type <comp_eq> comp_eq
%type <comp_gt> comp_gt
%type <comp_gt_eq> comp_gt_eq
%type <comp_in> comp_in
%type <comp_is> comp_is
%type <comp_lt> comp_lt
%type <comp_lt_eq> comp_lt_eq
%type <comp_not_eq> comp_not_eq
%type <comp_not_in> comp_not_in
%type <comp_not_is> comp_not_is
%type <continue_statement> continue_statement
%type <delete_statement> delete_statement
%type <function_definition> function_definition
%type <global_statement> global_statement
%type <if_statement> if_statement
%type <import_statement> import_statement
%type <op_band> op_band
%type <op_bnot> op_bnot
%type <op_bor> op_bor
%type <op_bxor> op_bxor
%type <op_divide> op_divide
%type <op_left_shift> op_left_shift
%type <op_minus> op_minus
%type <op_mod> op_mod
%type <op_mult> op_mult
%type <op_negative> op_negative
%type <op_plus> op_plus
%type <op_positive> op_positive
%type <op_power> op_power
%type <op_right_shift> op_right_shift
%type <op_trunc> op_trunc
%type <parameter_list_kwargs> parameter_list_kwargs
%type <parameter_list_non_args> parameter_list_non_args
%type <pass_statement> pass_statement
%type <print_statement> print_statement
%type <return_statement> return_statement
%type <suite> suite
%type <test_statement> test_statement
%type <while_statement> while_statement
%type <dotted_as_names> dotted_as_names
%type <import_as_names> import_as_names
%type <suite_body> suite_body
%type <test_list> test_list
%type <test_phrase> test_phrase
%type <inline_if_phrase> inline_if_phrase
%type <or_phrase> or_phrase
%type <simple_statement> simple_statement
%type <test_list_non_empty> test_list_non_empty
%type <and_phrase> and_phrase
%type <test_list_non_trailing> test_list_non_trailing
%type <not_phrase> not_phrase
%type <comparison_phrase> comparison_phrase
%type <comparison_list> comparison_list
%type <expression> expression
%type <xor_expression> xor_expression
%type <and_expression> and_expression
%type <shift_expression> shift_expression
%type <arith_expression> arith_expression
%type <mult_expression> mult_expression
%type <fact_expression> fact_expression
%type <unary_phrase> unary_phrase
%type <base_phrase> base_phrase
%type <function_call> function_call
%type <get_attr> get_attr
%type <get_item> get_item
%type <list_maker> list_maker
%type <name_phrase> name_phrase
%type <repr_phrase> repr_phrase
%type <test_phrase_bracketed> test_phrase_bracketed
%type <tuple_maker> tuple_maker
%type <value_float> value_float
%type <value_int> value_int
%type <value_string> value_string
%%
#line 341 "ast/autogen.py"

all_input: /* empty */ { }
         | all_input single_input { evaluate($2, context); }
         | all_input error TOK_NEWLINE { if (context->interpreterMode) yyerrok; else return 0; }
         | all_input TOK_INDENT error TOK_NEWLINE { if (context->interpreterMode) yyerrok; else return 0; }
         ;

arith_operator: 
              ;
comparison_operator: 
                   ;
dotted_name: 
           ;
mult_operator: 
             ;
parameter_list: 
              ;
parameter_list_args: 
                   ;
parameter_phrase: 
                ;
shift_operator: 
              ;
single_input: 
            ;
slice_list: 
          ;
slice_phrase: 
            ;
small_statement: 
               ;
test_phrase_optional: 
                    ;
unary_operator: 
              ;
assign_statement: 
                ;
break_statement: 
               ;
comp_eq: 
       ;
comp_gt: 
       ;
comp_gt_eq: 
          ;
comp_in: 
       ;
comp_is: 
       ;
comp_lt: 
       ;
comp_lt_eq: 
          ;
comp_not_eq: 
           ;
comp_not_in: 
           ;
comp_not_is: 
           ;
continue_statement: 
                  ;
delete_statement: 
                ;
function_definition: 
                   ;
global_statement: 
                ;
if_statement: 
            ;
import_statement: 
                ;
op_band: 
       ;
op_bnot: 
       ;
op_bor: 
      ;
op_bxor: 
       ;
op_divide: 
         ;
op_left_shift: 
             ;
op_minus: 
        ;
op_mod: 
      ;
op_mult: 
       ;
op_negative: 
           ;
op_plus: 
       ;
op_positive: 
           ;
op_power: 
        ;
op_right_shift: 
              ;
op_trunc: 
        ;
parameter_list_kwargs: 
                     ;
parameter_list_non_args: 
                       ;
pass_statement: 
              ;
print_statement: 
               ;
return_statement: 
                ;
suite: 
     ;
test_statement: 
              ;
while_statement: 
               ;
dotted_as_names: 
               ;
import_as_names: 
               ;
suite_body: 
          ;
test_list: 
         ;
test_phrase: 
           ;
inline_if_phrase: 
                ;
or_phrase: 
         ;
simple_statement: 
                ;
test_list_non_empty: 
                   ;
and_phrase: 
          ;
test_list_non_trailing: 
                      ;
not_phrase: 
          ;
comparison_phrase: 
                 ;
comparison_list: 
               ;
expression: 
          ;
xor_expression: 
              ;
and_expression: 
              ;
shift_expression: 
                ;
arith_expression: 
                ;
mult_expression: 
               ;
fact_expression: 
               ;
unary_phrase: 
            ;
base_phrase: 
           ;
function_call: 
             ;
get_attr: 
        ;
get_item: 
        ;
list_maker: 
          ;
name_phrase: 
           ;
repr_phrase: 
           ;
test_phrase_bracketed: 
                     ;
tuple_maker: 
           ;
value_float: 
           ;
value_int: 
         ;
value_string: 
            ;

%%
